<!DOCTYPE html> 
<html> 
    <head> 
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, maximum-scale=1.0" />

        <title>Lily's Final!</title> 

        <link href="style.css" media="screen" rel="stylesheet" type="text/css" />

    </head> 
    <!-- <body style="margin:0;padding:0"></body> -->
    <body style="margin:40;padding:0"> 
        <div class="header">
            <h1>Lily's Final Project!</h1>
            <br>Here is all the documentation for my project! <br>
            First, I have my brainstorms I did to come up with an idea... I wanted to make something to boogie in!
            <p>
            <img src="discosuit.jpg" width=400 class="rotateimg180"></a>
            </p> 
            <br>
            For my final project I am thinking I will make a disco suit. <br>
            So far, my ideas for this project include: <br>
            - Using an accelerometer on each of my limbs to register the intensity of my boogie-ing <br>
            - Depending on the speed of my dancing, LEDs in the suit would either: <br>
            ---> Change Color <br>
            ---> Change intensity <br>
            ---> Both <br>
            ---> Blink <br> <br>
            <br>
            <h3>Building the project!!</h3> <br>
            <h2>Schematic! <br></h2>
            Here is the schematic for my disco suit! <br>

            <p>
                <img src="schematic_FINAL.jpg" width=400 class="rotateimg90"></a>
            </p> <br>

            The RGB LED was connected through my code to the accelerometer. 
            The RGB LED was connected to the pwm pins 3, 5, and 6. <br> <br>

            I soldered the accelerometer to be able to use it in this project. 
            I connected Vin to 5V on the arduino; the SCL pin to Digital #13 pin; 
            the SDA pin to Digital #11 pin; the SDO pin to Digital #12 pin; the CS pin to Digital #10 pin. <br> <br>
            
            Here is a close-ip on the schematic for the accelerometer. <br><br>
            <p>
                <img src="accelerometer_schematicFINAL.jpg" width=400></a>
            </p> <br>            

            The LED strip was powered by 12V from the wall, 
            and connected to pin 9 and ground through the N-channel MOSFET transistor. 
            It was controlled through code by the tilt ball switch. <br>

            The tilt ball switch was connected to pin 4 and ground. <br>


            <h2>Circuit</h2> <br> <br>
            To put my project together, I migrated from the large breadboard to the tiny breadboard. 
            This fit perfectly on the Arduino cover, which I used to increase the stability of my project. 
            I tried to solder everything together at first, but the iron was taking 
            such a long time to heat everything (ie ~5 minutes per connection) that it was too fickle 
            to make my prototype with. I made one mistake and was then unable to remove the solder with 
            the iron, so I figured I would just solder the connections between wires, 
            but not solder everything to the breakout board.  <br> <br>

            Here are images of my circuit. <br> <br>

            <!-- <p>
                <img src="ard_circFIN.jpg" width=400></a>
            </p> <br> <br> -->
            <figure>
                <img src="ard_circFIN.jpg" alt="Circuit" style="width:40%">
                <figcaption>Circuit</figcaption>
              </figure>

            <h2>My code</h2> <br> <br>
            Here is my code. Much of the code for the accelerometer is taken from the Adafruit example in Arduino.
            <pre><code>
                // Much of the code for the accelerometer is from the Adafruit LIS3DH accelerometer example

                // initializes the tilt ball reading pin
                const int tiltSensorPin = 4; 
                // initialize j, the value I will use to count how many times the tilt ball switch
                // has been turned on and off
                int j; 
                
                // initializes the value that holds the last tilt state
                int state;
                // initializes the value that holds the reading of the tilt ball switch
                int tiltValue;
                // initializes the tilt state as HIGH
                int lastTiltState = HIGH; // the previous reading from the tilt sensor
                // saves the transistor pin to #9
                const int transPin = 9;
                
                // the following lines of code are from Adafruit. They explain that I need to save the 
                // time as longs so that as the time increases it can still be stored, even though 
                // it will quickly become too big to be stored as an int variable
                // the following variables are long's because the time, measured in miliseconds,
                // will quickly become a bigger number than can be stored in an int.
                long lastDebounceTime = 0; // the last time the output pin was toggled
                long debounceDelay = 50; // the debounce time; increase if the output flickers
                
                // this library helps me communicate from arduino to acccelerometer
                #include <Wire.h>
                // this library enables me to communicate with SPI devices (like the accelerometer)
                #include <SPI.h>
                // this library from Adafruit enables me to use the accelerometer + use things like the emaple code!
                #include <Adafruit_LIS3DH.h>
                // another Adafruit library, supports the Adafruit unified sensor abstraction layer (from Adafruit)
                #include <Adafruit_Sensor.h>
                
                // Used for software SPI
                // saving the pin names of the acclereometer to their arduino pins
                #define LIS3DH_CLK 13
                #define LIS3DH_MISO 12
                #define LIS3DH_MOSI 11
                // Used for hardware & software SPI
                #define LIS3DH_CS 10
                
                //from the Adafruit example
                // software SPI
                // initializes lis as the reading of the pins of the accelerometer
                Adafruit_LIS3DH lis = Adafruit_LIS3DH(LIS3DH_CS, LIS3DH_MOSI, LIS3DH_MISO, LIS3DH_CLK);
                // hardware SPI
                //Adafruit_LIS3DH lis = Adafruit_LIS3DH(LIS3DH_CS);
                // I2C
                //Adafruit_LIS3DH lis = Adafruit_LIS3DH();
                
                // saving the pin for the red part of the RGB LED
                const int RED = 6;
                // saving the pin for the green part of the RGB LED
                const int GREEN = 5;
                // saving the pin for the blue part of the RGB LED
                const int BLUE = 3;
                
                // the following three lines are initializing the three readings from the adruino as 0
                int z = 0;
                int x = 0;
                int y = 0;
                
                void setup() {
                  // put your setup code here, to run once:
                
                  // saves tilt switch pin as input
                  pinMode(tiltSensorPin, INPUT);
                  //
                  digitalWrite(tiltSensorPin, HIGH);
                  // saves led strip pin as output
                  
                  // Initialize serial communications
                  // This is so I can later see the values in the serial monitor
                  Serial.begin(9600);
                  
                  // transistor pin is set as output
                  pinMode(transPin, OUTPUT);
                
                  // will pause Zero, Leonardo, etc until serial console opens
                  while (!Serial) delay(10);     
                  // prints a test statement in serial
                  Serial.println("LIS3DH test!");
                
                  // checks if the transmission rate is not correct for the lis data
                  if (! lis.begin(0x18)) {
                    // error message
                    Serial.println("Couldnt start");
                    // creates loop within setup so it continues until the rate is correct
                    while (1) yield();
                  }
                  // if the transmission rate is correct, confirmation message to serial
                  Serial.println("LIS3DH found!");
                  // read range back from sensor (I used 4G)
                  lis.setRange(LIS3DH_RANGE_4_G);   // 2, 4, 8 or 16 G!
                
                  //prints range in serial monitor
                  Serial.print("Range = "); Serial.print(2 << lis.getRange());  
                  Serial.println("G");
                }
                
                void loop() {
                  // put your main code here, to run repeatedly:
                  lis.read();      // get X Y and Z data at once
                  // Then print out the raw data in serial
                  Serial.print("X:  "); Serial.print(lis.x); 
                  Serial.print("  \tY:  "); Serial.print(lis.y); 
                  Serial.print("  \tZ:  "); Serial.print(lis.z); 
                
                  // get new sensor event 
                  sensors_event_t event; 
                  lis.getEvent(&event);
                
                  // from the example code
                  // Display the results (acceleration is measured in m/s^2)
                  Serial.print("\t\tX: "); Serial.print(event.acceleration.x);
                  Serial.print(" \tY: "); Serial.print(event.acceleration.y); 
                  Serial.print(" \tZ: "); Serial.print(event.acceleration.z); 
                  Serial.println(" m/s^2 ");
                
                  // saving the acceleration in each direction as a variable
                  x = event.acceleration.x;
                  y = event.acceleration.y;
                  z = event.acceleration.z;
                
                  // new line in serial
                  Serial.println();
                
                  // delay 2/10 of a second
                  delay(200);
                
                  // check if x acceleration is positive or negative, ie whether 
                  // if you are moving right
                  if (x > 0) {
                    // makes RGB LED glow pink-ish
                    digitalWrite(GREEN, LOW);
                    analogWrite(RED, 80);
                    analogWrite(BLUE, 20);
                  // if you are moving left
                  } else if (x < 0) { 
                    // makes RGB LED glow teal
                    analogWrite(GREEN, 50);
                    digitalWrite(RED, LOW);
                    analogWrite(BLUE, 10);
                  }
                
                  // reads whether or not the tilt ball switch is tilted
                  tiltValue = digitalRead(tiltSensorPin);
                  // Checks if the switch has not changed:
                  if (tiltValue == lastTiltState) {
                    // reset the debouncing timer
                    // debouncing for error prevention
                    lastDebounceTime = millis();
                  }
                  // if the reading has been the same for a while (longer than the debounce delay)
                  if ((millis() - lastDebounceTime) > debounceDelay) {
                    // whatever the reading is at, it's been there for longer
                    // than the debounce delay, so take it as the actual current state:
                    lastTiltState = tiltValue;
                  }
                
                  // write the state to the LED strip to turn it on or off
                  digitalWrite(transPin, lastTiltState);
                  // if the last tilt state is 0
                  if (lastTiltState == 0){
                    // then turn off the LED strip
                    analogWrite(transPin, 0);
                  } else {
                    // if the tilt ball switch is on its first through fifth tilts
                    if (j < 5){
                      //Serial.println(j);
                      // turn the LED strip on and keep it on until the switch is turned off
                      analogWrite(transPin, 255);
                    } else {
                      //if the switch is on its sixth tilt turn it on and off repeatedly 
                      // with a longer break every 2 blinks of the LED
                      //Serial.println(j);
                      analogWrite(transPin, 0);
                      delay(100);
                      analogWrite(transPin, 255);
                      delay(100);
                      analogWrite(transPin, 0);
                      delay(100);
                      analogWrite(transPin, 255);
                      delay(100);
                    }
                    // if the switch has been turned
                    if (state != lastTiltState){
                      // increase j by one
                      j++;
                    }   
                    // if j is greater than 5
                    if (j > 5){
                      // set j back to 0
                      j = 0;
                    }
                  }
                  
                  // print the tilt state to seial
                  Serial.println(lastTiltState);
                  // delay half a second
                  delay(500);
                
                  // save the last tilt state as the state 
                  // so I can check if it has changed in the next loop
                  state = lastTiltState;
                }
            </code>
           
            <!-- This gif shows the operation of my circuit:<br>
            At different levels of light being read by the photoresistor, different things happen to the 
            LEDs. For bright light, like from overhead fluorescents, the red LED blinks slowly, on and off 
            for 400 milliseconds each. As the light reaching the photoresistor lessens, like when I cast 
            a shadow over it with my hand, the blinking goes faster, at 150 milliseconds each on and off. 
            When the photoresistor is in darkness, like when I covered it with my hand, the blinking is 
            very rapid, blinking on and off for 75 milliseconds each. <br>
            The yellow LED does not blink; rather, it gets brighter or dimmer along with the exposure 
            or shielding from light, respectively. <br>
            <p>
                <img src="circuit1.jpg" width=400></a>
                </p>
            <p>
            This image shows my circuit, which has two LEDs and a photoresistor. The LEDs have to be connected 
            to the pins with tildes (~) because these are the pins that allow for analogWrite()to write the 
            analog value measured by the photoresistor to the pin. <br> <br> <br>
                <img src="circuit2.jpg" width=400></a>
                </p>
            This is the side view of my circuit. <br> <br>
            <p>
                <img src="schematic3.jpg" width=400 class="rotateimg180"></a>
                </p>

            <br> <br> Lia Johansen/Prof. Nadya helped with this: <br> <br>
            To find the resistor value to use with the photoresistor, I had to do some calculations using 
            the min and max resistance of the photoresistor, depending on the amount of light it is exposed to. 
            I used the multimeter to get the max and min values, measuring when the lights were on, and when 
            the room was dark. These are the values I read: <br> <br>
            Rmin: 185 ohms <br>
            Rmax: 100k ohms <br> <br>
            
            Then, I looked for the resistor that would allow analogRead() to read the widest range of values possible 
            at the voltage divider. If the photoresistor were capturing the whole range, 
            the readings would go from 0-1023 (a full 5 volt range); mine only went from about 30 to 900, that's why I constrained 
            my range to those values in my void loop.<br> <br>
            Next, I calculated the Vout values for both the low and high resistance values; then, I subtracted 
            Vout_low from Vout_high to get the voltage range; 
            I checked for 220 ohms, and the range was pretty small, so I went up to 100k ohms, and the range was also small. 
            Then, I went down to 2k ohms and the range was 4.47V. I did the calculation for 10k ohms, and the range was slightly 
            smaller than the 2k resistor, at 4.45V. <br> <br>
            Even though the 10k resistor had a range that was a tiny bit smaller, I chose that resistor because I figured 
            using a higher resitor would be a safer bet, and the tiny difference in voltage range between 10k and 2k would 
                          -->
  
        </div>
        
    </body>
</html>
